import { createSelector } from '@ngrx/store';
import { ENTITY_OPTS_PROP, NAE_KEY_NAMES, NAE_KEYS } from '../decorators/entity-tokens';
import { entityStateName } from '../decorators/entity-util';
import { buildActionMap } from './action-map-builder';
import { buildFacade } from './facade-builder';
import { makeEntity } from './make-entity';
import { buildSelectorMap } from './selector-map-builder';
import { FEATURE_AFFINITY } from './util-tokens';
const sortAlpha = (aKey, bKey) => aKey.localeCompare(bKey);
const sortNumeric = (aKey, bKey) => aKey - bKey;
const defaultSort = (aKey, bKey) => typeof aKey === 'string' ? sortAlpha(aKey, bKey) : sortNumeric(aKey, bKey);
export const NO_ENTITY_DECORATOR_MSG = 
// eslint-disable-next-line max-len
'Specified model is not decorated with @Entity. All automatic entities must be decorated with a modelName specified. Building of state aborted!';
const ensureEntityDecorator = (type) => {
    if (!type[ENTITY_OPTS_PROP]) {
        const example = ` Example model with proper decoration:

@Entity({modelName: 'Test'})
export class Test {
  @Key yourKey: number | string;
  // ... other properties ...
}`;
        console.error('[NGRX-AE] ! ' + NO_ENTITY_DECORATOR_MSG + example);
        throw new Error(NO_ENTITY_DECORATOR_MSG);
    }
};
export const NO_ENTITY_KEY_MSG = 
// eslint-disable-next-line max-len
'Specified model has no properties decorated with @Key. All automatic entities must have at least one property identified as the entity key. Building of state aborted!';
const ensureEntityKey = (type) => {
    if (!type.prototype[NAE_KEY_NAMES] || !type.prototype[NAE_KEYS]) {
        const example = ` Example model with proper decoration:

@Entity({modelName: '${type[ENTITY_OPTS_PROP].modelName}'})
export class ${type[ENTITY_OPTS_PROP].modelName} {
  @Key yourKey: number | string;
  // ... other properties ...
}`;
        console.error('[NGRX-AE] ! ' + NO_ENTITY_KEY_MSG + example);
        throw new Error(NO_ENTITY_KEY_MSG);
    }
};
export const NO_MODEL_NAME_MSG = 
// eslint-disable-next-line max-len
'Specified model is decorated with @Entity but does not specify a modelName, which is required for proper production execution. Building of state aborted!';
const ensureModelName = (opts) => {
    if (!opts.modelName) {
        const example = ` Example model with proper decoration:

@Entity({modelName: 'Test'})
export class Test {
  @Key yourKey: number | string;
  // ... other properties ...
}`;
        console.error('[NGRX-AE] ! ' + NO_MODEL_NAME_MSG + example);
        throw new Error(NO_MODEL_NAME_MSG);
    }
};
/**
 * Builds the initial Ngrx state for an entity
 *
 * @param type - the entity class
 * @param extraInitialState - the (optional) initial state
 */
export const buildState = (type, extraInitialState) => {
    ensureEntityDecorator(type);
    ensureEntityKey(type);
    const opts = type[ENTITY_OPTS_PROP];
    ensureModelName(opts);
    const stateName = entityStateName(opts.modelName);
    const getState = (state) => {
        const modelState = state[stateName];
        if (!modelState) {
            // eslint-disable-next-line max-len
            const message = `State for model ${opts.modelName} could not be found! Make sure you add your entity state to the parent state with a property named exactly '${stateName}'.`;
            const example = ` Example app state:

export interface AppState {
  // ... other states ...
  ${stateName}: IEntityState<${opts.modelName}>,
  // ... other states ...
}`;
            console.error('[NGRX-AE] ! ' + message + example);
            throw new Error(message);
        }
        return modelState;
    };
    const initialState = {
        entities: {},
        ids: [],
        ...extraInitialState
    };
    /* eslint-disable @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match */
    let _actions;
    let _selectors;
    let _facade;
    let _reducer;
    const entityState = getState;
    let _makeEntity;
    /* eslint-enable @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match */
    class StateBuilder {
        get entityState() {
            return entityState;
        }
        get initialState() {
            return initialState;
        }
        get actions() {
            _actions = _actions || buildActionMap(type);
            return _actions;
        }
        get selectors() {
            _selectors = _selectors || buildSelectorMap(getState, type);
            return _selectors;
        }
        get reducer() {
            _reducer =
                _reducer ||
                    ((state = initialState) => {
                        return state;
                    });
            return _reducer;
        }
        get makeEntity() {
            _makeEntity = _makeEntity || makeEntity(type);
            return _makeEntity;
        }
        get facade() {
            _facade = _facade || buildFacade(this.selectors);
            return _facade;
        }
    }
    const built = new StateBuilder();
    return built;
};
/**
 * Builds the Ngrx state for an entity that is part of a feature module
 *
 * @param type the entity class
 * @param featureStateName the name of the feature state
 * @param selectParentState a selector for the entity's parent state
 * @param extraInitialState the (optional) initial feature state
 */
export const buildFeatureState = (type, featureStateName, selectParentState, extraInitialState) => {
    ensureEntityDecorator(type);
    ensureEntityKey(type);
    const opts = type[ENTITY_OPTS_PROP];
    ensureModelName(opts);
    const stateName = entityStateName(opts.modelName);
    type[FEATURE_AFFINITY] = featureStateName;
    const selectState = createSelector(selectParentState, (state) => {
        if (!state) {
            // eslint-disable-next-line max-len
            const message = `Could not retrieve feature state ${featureStateName} for model ${opts.modelName}! Make sure you add your entity state to the feature state with a property named exactly '${stateName}'.`;
            const example = ` Example app state:

export interface FeatureState {
  // ... other states ...
  ${stateName}: IEntityState<${opts.modelName}>,
  // ... other states ...
}`;
            console.error('[NGRX-AE] ! ' + message + example);
            throw new Error(message);
        }
        const modelState = state[stateName];
        if (!modelState) {
            const message = `State for model ${opts.modelName} in feature ${featureStateName} could not be found!`;
            console.error('[NGRX-AE] ! ' + message);
            throw new Error(message);
        }
        return modelState;
    });
    const initialState = {
        entities: {},
        ids: [],
        ...extraInitialState
    };
    /* eslint-disable @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match */
    let _actions;
    let _selectors;
    let _facade;
    let _reducer;
    const entityState = selectState;
    let _makeEntity;
    /* eslint-enable @typescript-eslint/naming-convention, no-underscore-dangle, id-blacklist, id-match */
    class StateBuilder {
        get entityState() {
            return entityState;
        }
        get initialState() {
            return initialState;
        }
        get actions() {
            _actions = _actions || buildActionMap(type);
            return _actions;
        }
        get selectors() {
            _selectors = _selectors || buildSelectorMap(selectState, type);
            return _selectors;
        }
        get reducer() {
            _reducer =
                _reducer ||
                    ((state = initialState) => {
                        return state;
                    });
            return _reducer;
        }
        get makeEntity() {
            _makeEntity = _makeEntity || makeEntity(type);
            return _makeEntity;
        }
        get facade() {
            _facade = _facade || buildFacade(this.selectors);
            return _facade;
        }
    }
    const built = new StateBuilder();
    return built;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25ncngtYXV0by1lbnRpdHkvc3JjL2xpYi91dGlsL3N0YXRlLWJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFVLGNBQWMsRUFBb0IsTUFBTSxhQUFhLENBQUM7QUFFdkUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN4RixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHNUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXRELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzFELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVqRCxNQUFNLFNBQVMsR0FBRyxDQUFDLElBQVksRUFBRSxJQUFZLEVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFbkYsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFVLEVBQUUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBRXhFLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBb0IsRUFBRSxJQUFvQixFQUFVLEVBQUUsQ0FDekUsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLElBQWMsQ0FBQyxDQUFDO0FBRWpHLE1BQU0sQ0FBQyxNQUFNLHVCQUF1QjtBQUNs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QUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QyxPQUFPLFdBQVcsQ0FBQztRQUNyQixDQUFDO1FBRUQsSUFBSSxNQUFNO1lBQ1IsT0FBTyxHQUFHLE9BQU8sSUFBSSxXQUFXLENBQXVCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN2RSxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO0tBQ0Y7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ2pDLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBjcmVhdGVTZWxlY3RvciwgTWVtb2l6ZWRTZWxlY3RvciB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IElFbnRpdHlPcHRpb25zIH0gZnJvbSAnLi4vZGVjb3JhdG9ycy9lbnRpdHktb3B0aW9ucyc7XG5pbXBvcnQgeyBFTlRJVFlfT1BUU19QUk9QLCBOQUVfS0VZX05BTUVTLCBOQUVfS0VZUyB9IGZyb20gJy4uL2RlY29yYXRvcnMvZW50aXR5LXRva2Vucyc7XG5pbXBvcnQgeyBlbnRpdHlTdGF0ZU5hbWUgfSBmcm9tICcuLi9kZWNvcmF0b3JzL2VudGl0eS11dGlsJztcbmltcG9ydCB7IEVudGl0eUlkZW50aXR5IH0gZnJvbSAnLi4vdHlwZXMvZW50aXR5LWlkZW50aXR5JztcbmltcG9ydCB7IElBY3Rpb25NYXAgfSBmcm9tICcuL2FjdGlvbi1tYXAnO1xuaW1wb3J0IHsgYnVpbGRBY3Rpb25NYXAgfSBmcm9tICcuL2FjdGlvbi1tYXAtYnVpbGRlcic7XG5pbXBvcnQgeyBJRW50aXR5U3RhdGUgfSBmcm9tICcuL2VudGl0eS1zdGF0ZSc7XG5pbXBvcnQgeyBidWlsZEZhY2FkZSB9IGZyb20gJy4vZmFjYWRlLWJ1aWxkZXInO1xuaW1wb3J0IHsgbWFrZUVudGl0eSB9IGZyb20gJy4vbWFrZS1lbnRpdHknO1xuaW1wb3J0IHsgSU1vZGVsQ2xhc3MsIElNb2RlbFN0YXRlIH0gZnJvbSAnLi9tb2RlbC1zdGF0ZSc7XG5pbXBvcnQgeyBJU2VsZWN0b3JNYXAgfSBmcm9tICcuL3NlbGVjdG9yLW1hcCc7XG5pbXBvcnQgeyBidWlsZFNlbGVjdG9yTWFwIH0gZnJvbSAnLi9zZWxlY3Rvci1tYXAtYnVpbGRlcic7XG5pbXBvcnQgeyBGRUFUVVJFX0FGRklOSVRZIH0gZnJvbSAnLi91dGlsLXRva2Vucyc7XG5cbmNvbnN0IHNvcnRBbHBoYSA9IChhS2V5OiBzdHJpbmcsIGJLZXk6IHN0cmluZyk6IG51bWJlciA9PiBhS2V5LmxvY2FsZUNvbXBhcmUoYktleSk7XG5cbmNvbnN0IHNvcnROdW1lcmljID0gKGFLZXk6IG51bWJlciwgYktleTogbnVtYmVyKTogbnVtYmVyID0+IGFLZXkgLSBiS2V5O1xuXG5jb25zdCBkZWZhdWx0U29ydCA9IChhS2V5OiBFbnRpdHlJZGVudGl0eSwgYktleTogRW50aXR5SWRlbnRpdHkpOiBudW1iZXIgPT5cbiAgdHlwZW9mIGFLZXkgPT09ICdzdHJpbmcnID8gc29ydEFscGhhKGFLZXksIGJLZXkgYXMgc3RyaW5nKSA6IHNvcnROdW1lcmljKGFLZXksIGJLZXkgYXMgbnVtYmVyKTtcblxuZXhwb3J0IGNvbnN0IE5PX0VOVElUWV9ERUNPUkFUT1JfTVNHID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgJ1NwZWNpZmllZCBtb2RlbCBpcyBub3QgZGVjb3JhdGVkIHdpdGggQEVudGl0eS4gQWxsIGF1dG9tYXRpYyBlbnRpdGllcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIGEgbW9kZWxOYW1lIHNwZWNpZmllZC4gQnVpbGRpbmcgb2Ygc3RhdGUgYWJvcnRlZCEnO1xuY29uc3QgZW5zdXJlRW50aXR5RGVjb3JhdG9yID0gPFRNb2RlbD4odHlwZTogSU1vZGVsQ2xhc3M8VE1vZGVsPik6IHZvaWQgPT4ge1xuICBpZiAoIXR5cGVbRU5USVRZX09QVFNfUFJPUF0pIHtcbiAgICBjb25zdCBleGFtcGxlID0gYCBFeGFtcGxlIG1vZGVsIHdpdGggcHJvcGVyIGRlY29yYXRpb246XG5cbkBFbnRpdHkoe21vZGVsTmFtZTogJ1Rlc3QnfSlcbmV4cG9ydCBjbGFzcyBUZXN0IHtcbiAgQEtleSB5b3VyS2V5OiBudW1iZXIgfCBzdHJpbmc7XG4gIC8vIC4uLiBvdGhlciBwcm9wZXJ0aWVzIC4uLlxufWA7XG4gICAgY29uc29sZS5lcnJvcignW05HUlgtQUVdICEgJyArIE5PX0VOVElUWV9ERUNPUkFUT1JfTVNHICsgZXhhbXBsZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKE5PX0VOVElUWV9ERUNPUkFUT1JfTVNHKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IE5PX0VOVElUWV9LRVlfTVNHID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgJ1NwZWNpZmllZCBtb2RlbCBoYXMgbm8gcHJvcGVydGllcyBkZWNvcmF0ZWQgd2l0aCBAS2V5LiBBbGwgYXV0b21hdGljIGVudGl0aWVzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvcGVydHkgaWRlbnRpZmllZCBhcyB0aGUgZW50aXR5IGtleS4gQnVpbGRpbmcgb2Ygc3RhdGUgYWJvcnRlZCEnO1xuY29uc3QgZW5zdXJlRW50aXR5S2V5ID0gPFRNb2RlbD4odHlwZTogSU1vZGVsQ2xhc3M8VE1vZGVsPik6IHZvaWQgPT4ge1xuICBpZiAoIXR5cGUucHJvdG90eXBlW05BRV9LRVlfTkFNRVNdIHx8ICF0eXBlLnByb3RvdHlwZVtOQUVfS0VZU10pIHtcbiAgICBjb25zdCBleGFtcGxlID0gYCBFeGFtcGxlIG1vZGVsIHdpdGggcHJvcGVyIGRlY29yYXRpb246XG5cbkBFbnRpdHkoe21vZGVsTmFtZTogJyR7dHlwZVtFTlRJVFlfT1BUU19QUk9QXS5tb2RlbE5hbWV9J30pXG5leHBvcnQgY2xhc3MgJHt0eXBlW0VOVElUWV9PUFRTX1BST1BdLm1vZGVsTmFtZX0ge1xuICBAS2V5IHlvdXJLZXk6IG51bWJlciB8IHN0cmluZztcbiAgLy8gLi4uIG90aGVyIHByb3BlcnRpZXMgLi4uXG59YDtcbiAgICBjb25zb2xlLmVycm9yKCdbTkdSWC1BRV0gISAnICsgTk9fRU5USVRZX0tFWV9NU0cgKyBleGFtcGxlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoTk9fRU5USVRZX0tFWV9NU0cpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgTk9fTU9ERUxfTkFNRV9NU0cgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAnU3BlY2lmaWVkIG1vZGVsIGlzIGRlY29yYXRlZCB3aXRoIEBFbnRpdHkgYnV0IGRvZXMgbm90IHNwZWNpZnkgYSBtb2RlbE5hbWUsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBwcm9wZXIgcHJvZHVjdGlvbiBleGVjdXRpb24uIEJ1aWxkaW5nIG9mIHN0YXRlIGFib3J0ZWQhJztcbmNvbnN0IGVuc3VyZU1vZGVsTmFtZSA9IChvcHRzOiBJRW50aXR5T3B0aW9ucykgPT4ge1xuICBpZiAoIW9wdHMubW9kZWxOYW1lKSB7XG4gICAgY29uc3QgZXhhbXBsZSA9IGAgRXhhbXBsZSBtb2RlbCB3aXRoIHByb3BlciBkZWNvcmF0aW9uOlxuXG5ARW50aXR5KHttb2RlbE5hbWU6ICdUZXN0J30pXG5leHBvcnQgY2xhc3MgVGVzdCB7XG4gIEBLZXkgeW91cktleTogbnVtYmVyIHwgc3RyaW5nO1xuICAvLyAuLi4gb3RoZXIgcHJvcGVydGllcyAuLi5cbn1gO1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tOR1JYLUFFXSAhICcgKyBOT19NT0RFTF9OQU1FX01TRyArIGV4YW1wbGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihOT19NT0RFTF9OQU1FX01TRyk7XG4gIH1cbn07XG5cbi8qKlxuICogQnVpbGRzIHRoZSBpbml0aWFsIE5ncnggc3RhdGUgZm9yIGFuIGVudGl0eVxuICpcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIGVudGl0eSBjbGFzc1xuICogQHBhcmFtIGV4dHJhSW5pdGlhbFN0YXRlIC0gdGhlIChvcHRpb25hbCkgaW5pdGlhbCBzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgYnVpbGRTdGF0ZSA9IDxUU3RhdGUgZXh0ZW5kcyBJRW50aXR5U3RhdGU8VE1vZGVsPiwgVFBhcmVudFN0YXRlIGV4dGVuZHMgYW55LCBUTW9kZWwsIFRFeHRyYT4oXG4gIHR5cGU6IElNb2RlbENsYXNzPFRNb2RlbD4sXG4gIGV4dHJhSW5pdGlhbFN0YXRlPzogVEV4dHJhXG4pOiBJTW9kZWxTdGF0ZTxUUGFyZW50U3RhdGUsIFRTdGF0ZSwgVE1vZGVsLCBURXh0cmE+ID0+IHtcbiAgZW5zdXJlRW50aXR5RGVjb3JhdG9yKHR5cGUpO1xuICBlbnN1cmVFbnRpdHlLZXkodHlwZSk7XG5cbiAgY29uc3Qgb3B0cyA9IHR5cGVbRU5USVRZX09QVFNfUFJPUF07XG4gIGVuc3VyZU1vZGVsTmFtZShvcHRzKTtcblxuICBjb25zdCBzdGF0ZU5hbWUgPSBlbnRpdHlTdGF0ZU5hbWUob3B0cy5tb2RlbE5hbWUpO1xuXG4gIGNvbnN0IGdldFN0YXRlID0gKHN0YXRlOiBUUGFyZW50U3RhdGUpOiBUU3RhdGUgJiBURXh0cmEgPT4ge1xuICAgIGNvbnN0IG1vZGVsU3RhdGUgPSBzdGF0ZVtzdGF0ZU5hbWVdO1xuICAgIGlmICghbW9kZWxTdGF0ZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgU3RhdGUgZm9yIG1vZGVsICR7b3B0cy5tb2RlbE5hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZCEgTWFrZSBzdXJlIHlvdSBhZGQgeW91ciBlbnRpdHkgc3RhdGUgdG8gdGhlIHBhcmVudCBzdGF0ZSB3aXRoIGEgcHJvcGVydHkgbmFtZWQgZXhhY3RseSAnJHtzdGF0ZU5hbWV9Jy5gO1xuICAgICAgY29uc3QgZXhhbXBsZSA9IGAgRXhhbXBsZSBhcHAgc3RhdGU6XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwU3RhdGUge1xuICAvLyAuLi4gb3RoZXIgc3RhdGVzIC4uLlxuICAke3N0YXRlTmFtZX06IElFbnRpdHlTdGF0ZTwke29wdHMubW9kZWxOYW1lfT4sXG4gIC8vIC4uLiBvdGhlciBzdGF0ZXMgLi4uXG59YDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOR1JYLUFFXSAhICcgKyBtZXNzYWdlICsgZXhhbXBsZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbFN0YXRlO1xuICB9O1xuXG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlbnRpdGllczoge30sXG4gICAgaWRzOiBbXSxcbiAgICAuLi5leHRyYUluaXRpYWxTdGF0ZVxuICB9IGFzIFRTdGF0ZSAmIFRFeHRyYTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sbm8tdW5kZXJzY29yZS1kYW5nbGUsaWQtYmxhY2tsaXN0LGlkLW1hdGNoICovXG4gIGxldCBfYWN0aW9uczogSUFjdGlvbk1hcDxUTW9kZWw+O1xuICBsZXQgX3NlbGVjdG9yczogSVNlbGVjdG9yTWFwPFRQYXJlbnRTdGF0ZSwgVE1vZGVsPjtcbiAgbGV0IF9mYWNhZGU7XG4gIGxldCBfcmVkdWNlcjogKHN0YXRlOiBJRW50aXR5U3RhdGU8VE1vZGVsPiAmIFRFeHRyYSkgPT4gSUVudGl0eVN0YXRlPFRNb2RlbD4gJiBURXh0cmE7XG5cbiAgY29uc3QgZW50aXR5U3RhdGUgPSBnZXRTdGF0ZSBhcyAoc3RhdGU6IFRQYXJlbnRTdGF0ZSkgPT4gVFN0YXRlICYgVEV4dHJhO1xuICBsZXQgX21ha2VFbnRpdHk6IChvYmo6IGFueSkgPT4gVE1vZGVsO1xuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbixuby11bmRlcnNjb3JlLWRhbmdsZSxpZC1ibGFja2xpc3QsaWQtbWF0Y2ggKi9cblxuICBjbGFzcyBTdGF0ZUJ1aWxkZXIge1xuICAgIGdldCBlbnRpdHlTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBlbnRpdHlTdGF0ZTtcbiAgICB9XG5cbiAgICBnZXQgaW5pdGlhbFN0YXRlKCkge1xuICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICB9XG5cbiAgICBnZXQgYWN0aW9ucygpIHtcbiAgICAgIF9hY3Rpb25zID0gX2FjdGlvbnMgfHwgYnVpbGRBY3Rpb25NYXAodHlwZSk7XG4gICAgICByZXR1cm4gX2FjdGlvbnM7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgIF9zZWxlY3RvcnMgPSBfc2VsZWN0b3JzIHx8IGJ1aWxkU2VsZWN0b3JNYXA8VFBhcmVudFN0YXRlLCBUU3RhdGUsIFRNb2RlbCwgVEV4dHJhPihnZXRTdGF0ZSwgdHlwZSk7XG4gICAgICByZXR1cm4gX3NlbGVjdG9ycztcbiAgICB9XG5cbiAgICBnZXQgcmVkdWNlcigpIHtcbiAgICAgIF9yZWR1Y2VyID1cbiAgICAgICAgX3JlZHVjZXIgfHxcbiAgICAgICAgKChzdGF0ZSA9IGluaXRpYWxTdGF0ZSk6IElFbnRpdHlTdGF0ZTxUTW9kZWw+ICYgVEV4dHJhID0+IHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyO1xuICAgIH1cblxuICAgIGdldCBtYWtlRW50aXR5KCkge1xuICAgICAgX21ha2VFbnRpdHkgPSBfbWFrZUVudGl0eSB8fCBtYWtlRW50aXR5KHR5cGUpO1xuICAgICAgcmV0dXJuIF9tYWtlRW50aXR5O1xuICAgIH1cblxuICAgIGdldCBmYWNhZGUoKSB7XG4gICAgICBfZmFjYWRlID0gX2ZhY2FkZSB8fCBidWlsZEZhY2FkZTxUTW9kZWwsIFRQYXJlbnRTdGF0ZT4odGhpcy5zZWxlY3RvcnMpO1xuICAgICAgcmV0dXJuIF9mYWNhZGU7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVpbHQgPSBuZXcgU3RhdGVCdWlsZGVyKCk7XG4gIHJldHVybiBidWlsdDtcbn07XG5cbi8qKlxuICogQnVpbGRzIHRoZSBOZ3J4IHN0YXRlIGZvciBhbiBlbnRpdHkgdGhhdCBpcyBwYXJ0IG9mIGEgZmVhdHVyZSBtb2R1bGVcbiAqXG4gKiBAcGFyYW0gdHlwZSB0aGUgZW50aXR5IGNsYXNzXG4gKiBAcGFyYW0gZmVhdHVyZVN0YXRlTmFtZSB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSBzdGF0ZVxuICogQHBhcmFtIHNlbGVjdFBhcmVudFN0YXRlIGEgc2VsZWN0b3IgZm9yIHRoZSBlbnRpdHkncyBwYXJlbnQgc3RhdGVcbiAqIEBwYXJhbSBleHRyYUluaXRpYWxTdGF0ZSB0aGUgKG9wdGlvbmFsKSBpbml0aWFsIGZlYXR1cmUgc3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1aWxkRmVhdHVyZVN0YXRlID0gPFRTdGF0ZSBleHRlbmRzIElFbnRpdHlTdGF0ZTxUTW9kZWw+LCBUUGFyZW50U3RhdGUgZXh0ZW5kcyBhbnksIFRNb2RlbCwgVEV4dHJhPihcbiAgdHlwZTogSU1vZGVsQ2xhc3M8VE1vZGVsPixcbiAgZmVhdHVyZVN0YXRlTmFtZTogTm9uTnVsbGFibGU8c3RyaW5nPixcbiAgc2VsZWN0UGFyZW50U3RhdGU6IE1lbW9pemVkU2VsZWN0b3I8b2JqZWN0LCBUUGFyZW50U3RhdGU+LFxuICBleHRyYUluaXRpYWxTdGF0ZT86IFRFeHRyYVxuKTogSU1vZGVsU3RhdGU8VFBhcmVudFN0YXRlLCBUU3RhdGUsIFRNb2RlbCwgVEV4dHJhPiA9PiB7XG4gIGVuc3VyZUVudGl0eURlY29yYXRvcih0eXBlKTtcbiAgZW5zdXJlRW50aXR5S2V5KHR5cGUpO1xuXG4gIGNvbnN0IG9wdHMgPSB0eXBlW0VOVElUWV9PUFRTX1BST1BdO1xuICBlbnN1cmVNb2RlbE5hbWUob3B0cyk7XG5cbiAgY29uc3Qgc3RhdGVOYW1lID0gZW50aXR5U3RhdGVOYW1lKG9wdHMubW9kZWxOYW1lKTtcblxuICAodHlwZSBhcyBhbnkpW0ZFQVRVUkVfQUZGSU5JVFldID0gZmVhdHVyZVN0YXRlTmFtZTtcblxuICBjb25zdCBzZWxlY3RTdGF0ZSA9IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdFBhcmVudFN0YXRlLCAoc3RhdGU6IFRQYXJlbnRTdGF0ZSkgPT4ge1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBjb25zdCBtZXNzYWdlID0gYENvdWxkIG5vdCByZXRyaWV2ZSBmZWF0dXJlIHN0YXRlICR7ZmVhdHVyZVN0YXRlTmFtZX0gZm9yIG1vZGVsICR7b3B0cy5tb2RlbE5hbWV9ISBNYWtlIHN1cmUgeW91IGFkZCB5b3VyIGVudGl0eSBzdGF0ZSB0byB0aGUgZmVhdHVyZSBzdGF0ZSB3aXRoIGEgcHJvcGVydHkgbmFtZWQgZXhhY3RseSAnJHtzdGF0ZU5hbWV9Jy5gO1xuICAgICAgY29uc3QgZXhhbXBsZSA9IGAgRXhhbXBsZSBhcHAgc3RhdGU6XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmVhdHVyZVN0YXRlIHtcbiAgLy8gLi4uIG90aGVyIHN0YXRlcyAuLi5cbiAgJHtzdGF0ZU5hbWV9OiBJRW50aXR5U3RhdGU8JHtvcHRzLm1vZGVsTmFtZX0+LFxuICAvLyAuLi4gb3RoZXIgc3RhdGVzIC4uLlxufWA7XG4gICAgICBjb25zb2xlLmVycm9yKCdbTkdSWC1BRV0gISAnICsgbWVzc2FnZSArIGV4YW1wbGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFN0YXRlID0gc3RhdGVbc3RhdGVOYW1lXTtcbiAgICBpZiAoIW1vZGVsU3RhdGUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgU3RhdGUgZm9yIG1vZGVsICR7b3B0cy5tb2RlbE5hbWV9IGluIGZlYXR1cmUgJHtmZWF0dXJlU3RhdGVOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQhYDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOR1JYLUFFXSAhICcgKyBtZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsU3RhdGU7XG4gIH0pO1xuXG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBlbnRpdGllczoge30sXG4gICAgaWRzOiBbXSxcbiAgICAuLi5leHRyYUluaXRpYWxTdGF0ZVxuICB9IGFzIFRTdGF0ZSAmIFRFeHRyYTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sbm8tdW5kZXJzY29yZS1kYW5nbGUsaWQtYmxhY2tsaXN0LGlkLW1hdGNoICovXG4gIGxldCBfYWN0aW9uczogSUFjdGlvbk1hcDxUTW9kZWw+O1xuICBsZXQgX3NlbGVjdG9yczogSVNlbGVjdG9yTWFwPFRQYXJlbnRTdGF0ZSwgVE1vZGVsPjtcbiAgbGV0IF9mYWNhZGU7XG4gIGxldCBfcmVkdWNlcjogKHN0YXRlOiBJRW50aXR5U3RhdGU8VE1vZGVsPiAmIFRFeHRyYSkgPT4gSUVudGl0eVN0YXRlPFRNb2RlbD4gJiBURXh0cmE7XG5cbiAgY29uc3QgZW50aXR5U3RhdGUgPSBzZWxlY3RTdGF0ZSBhcyBNZW1vaXplZFNlbGVjdG9yPFRQYXJlbnRTdGF0ZSwgVFN0YXRlICYgVEV4dHJhPjtcbiAgbGV0IF9tYWtlRW50aXR5OiAob2JqOiBhbnkpID0+IFRNb2RlbDtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBpZC1ibGFja2xpc3QsIGlkLW1hdGNoICovXG5cbiAgY2xhc3MgU3RhdGVCdWlsZGVyIHtcbiAgICBnZXQgZW50aXR5U3RhdGUoKSB7XG4gICAgICByZXR1cm4gZW50aXR5U3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IGluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IGFjdGlvbnMoKSB7XG4gICAgICBfYWN0aW9ucyA9IF9hY3Rpb25zIHx8IGJ1aWxkQWN0aW9uTWFwKHR5cGUpO1xuICAgICAgcmV0dXJuIF9hY3Rpb25zO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgICBfc2VsZWN0b3JzID0gX3NlbGVjdG9ycyB8fCBidWlsZFNlbGVjdG9yTWFwPFRQYXJlbnRTdGF0ZSwgVFN0YXRlLCBUTW9kZWwsIFRFeHRyYT4oc2VsZWN0U3RhdGUsIHR5cGUpO1xuICAgICAgcmV0dXJuIF9zZWxlY3RvcnM7XG4gICAgfVxuXG4gICAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgICBfcmVkdWNlciA9XG4gICAgICAgIF9yZWR1Y2VyIHx8XG4gICAgICAgICgoc3RhdGUgPSBpbml0aWFsU3RhdGUpOiBJRW50aXR5U3RhdGU8VE1vZGVsPiAmIFRFeHRyYSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBfcmVkdWNlcjtcbiAgICB9XG5cbiAgICBnZXQgbWFrZUVudGl0eSgpIHtcbiAgICAgIF9tYWtlRW50aXR5ID0gX21ha2VFbnRpdHkgfHwgbWFrZUVudGl0eSh0eXBlKTtcbiAgICAgIHJldHVybiBfbWFrZUVudGl0eTtcbiAgICB9XG5cbiAgICBnZXQgZmFjYWRlKCkge1xuICAgICAgX2ZhY2FkZSA9IF9mYWNhZGUgfHwgYnVpbGRGYWNhZGU8VE1vZGVsLCBUUGFyZW50U3RhdGU+KHRoaXMuc2VsZWN0b3JzKTtcbiAgICAgIHJldHVybiBfZmFjYWRlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1aWx0ID0gbmV3IFN0YXRlQnVpbGRlcigpO1xuICByZXR1cm4gYnVpbHQ7XG59O1xuIl19